<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CortexOS Dashboard</title>
<style>
  :root {
    --bg: #0d1117; --bg-card: #161b22; --border: #30363d;
    --text: #c9d1d9; --text-dim: #8b949e; --text-bright: #f0f6fc;
    --accent: #58a6ff; --success: #3fb950; --error: #f85149;
    --warning: #d29922; --purple: #bc8cff;
    --stage-idle: #30363d; --stage-running: #1f6feb;
    --stage-done: #238636; --stage-error: #da3633;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: var(--bg); color: var(--text); line-height: 1.5; }

  /* Header */
  .header { padding: 1rem 2rem; border-bottom: 1px solid var(--border);
    display: flex; align-items: center; gap: 1rem; }
  .header h1 { font-size: 1.25rem; color: var(--text-bright); font-weight: 600; }
  .header .badge { font-size: 0.75rem; padding: 2px 8px; border-radius: 12px;
    background: var(--stage-idle); color: var(--text-dim); }
  .header .badge.connected { background: var(--success); color: #fff; }
  .header .stats { margin-left: auto; display: flex; gap: 1.5rem; font-size: 0.85rem; color: var(--text-dim); }
  .header .stats span { color: var(--text-bright); font-weight: 500; }

  /* Layout */
  .container { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; padding: 1.5rem 2rem; }
  .full-width { grid-column: 1 / -1; }

  /* Cards */
  .card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; padding: 1rem 1.25rem; }
  .card h2 { font-size: 0.875rem; color: var(--text-dim); text-transform: uppercase;
    letter-spacing: 0.05em; margin-bottom: 0.75rem; font-weight: 500; }

  /* Pipeline View */
  .pipeline { display: flex; gap: 4px; align-items: center; }
  .stage { flex: 1; padding: 0.5rem 0.25rem; text-align: center; border-radius: 6px;
    background: var(--stage-idle); font-size: 0.7rem; font-weight: 500;
    transition: background 0.3s, color 0.3s; color: var(--text-dim); }
  .stage.running { background: var(--stage-running); color: #fff; animation: pulse 1.5s infinite; }
  .stage.done { background: var(--stage-done); color: #fff; }
  .stage.error { background: var(--stage-error); color: #fff; }
  .stage-arrow { color: var(--text-dim); font-size: 0.7rem; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.7; } }

  /* Metrics Grid */
  .metrics-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75rem; }
  .metric { text-align: center; }
  .metric .value { font-size: 1.5rem; font-weight: 700; color: var(--text-bright); }
  .metric .label { font-size: 0.75rem; color: var(--text-dim); }

  /* Waterfall */
  .waterfall { max-height: 300px; overflow-y: auto; }
  .waterfall-row { display: flex; align-items: center; gap: 0.5rem; padding: 2px 0;
    font-size: 0.75rem; border-bottom: 1px solid var(--border); }
  .waterfall-name { width: 120px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .waterfall-bar-container { flex: 1; height: 16px; position: relative; background: var(--bg); border-radius: 3px; }
  .waterfall-bar { position: absolute; height: 100%; border-radius: 3px; min-width: 2px; }
  .waterfall-bar.pipeline { background: var(--accent); }
  .waterfall-bar.stage { background: var(--success); }
  .waterfall-bar.agent { background: var(--purple); }
  .waterfall-bar.tool { background: var(--warning); }
  .waterfall-bar.llm { background: #f97583; }
  .waterfall-bar.memory { background: #56d364; }
  .waterfall-bar.quality { background: #79c0ff; }
  .waterfall-time { width: 60px; text-align: right; color: var(--text-dim); }

  /* Activity Feed */
  .feed { max-height: 300px; overflow-y: auto; }
  .feed-item { padding: 0.4rem 0; border-bottom: 1px solid var(--border);
    display: flex; gap: 0.5rem; align-items: baseline; font-size: 0.8rem; }
  .feed-time { color: var(--text-dim); font-family: monospace; font-size: 0.7rem; width: 70px; }
  .feed-event { padding: 1px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: 500;
    background: var(--border); color: var(--text); white-space: nowrap; }
  .feed-event.start { background: #1f6feb33; color: var(--accent); }
  .feed-event.complete { background: #23863633; color: var(--success); }
  .feed-event.error { background: #da363333; color: var(--error); }
  .feed-msg { color: var(--text-dim); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

  /* Empty state */
  .empty { text-align: center; padding: 2rem; color: var(--text-dim); font-style: italic; }

  /* Chart canvas */
  .chart-container { height: 200px; position: relative; }
  .chart-container canvas { width: 100%; height: 100%; }

  /* Tabs */
  .tabs { display: flex; gap: 0; border-bottom: 1px solid var(--border); padding: 0 2rem; }
  .tab { padding: 0.75rem 1.25rem; cursor: pointer; font-size: 0.85rem;
    color: var(--text-dim); border-bottom: 2px solid transparent; transition: all 0.2s; }
  .tab:hover { color: var(--text); }
  .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
  .tab-content { display: none; }
  .tab-content.active { display: block; }

  /* Agent Topology Graph */
  .topology-canvas { height: 300px; background: var(--bg); border-radius: 6px; position: relative; }
  .topology-canvas canvas { width: 100%; height: 100%; }
  .topology-legend { display: flex; gap: 1rem; margin-top: 0.5rem; font-size: 0.75rem; }
  .legend-item { display: flex; align-items: center; gap: 4px; }
  .legend-dot { width: 8px; height: 8px; border-radius: 50%; }

  /* Memory Explorer */
  .memory-list { max-height: 300px; overflow-y: auto; }
  .memory-item { padding: 0.5rem; border-bottom: 1px solid var(--border);
    display: flex; gap: 0.75rem; align-items: flex-start; font-size: 0.8rem; }
  .memory-type { padding: 1px 6px; border-radius: 4px; font-size: 0.65rem;
    font-weight: 600; text-transform: uppercase; white-space: nowrap; }
  .memory-type.semantic { background: #1f6feb33; color: var(--accent); }
  .memory-type.episodic { background: #23863633; color: var(--success); }
  .memory-type.working { background: #d2992233; color: var(--warning); }
  .memory-content { flex: 1; color: var(--text-dim); overflow: hidden;
    text-overflow: ellipsis; white-space: nowrap; }
  .memory-score { font-family: monospace; font-size: 0.75rem; color: var(--text-dim); }

  /* Surface Status */
  .surface-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 0.75rem; }
  .surface-card { padding: 0.75rem; background: var(--bg); border-radius: 6px; border: 1px solid var(--border); }
  .surface-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; }
  .surface-icon { font-size: 1.25rem; }
  .surface-name { font-weight: 600; font-size: 0.85rem; color: var(--text-bright); }
  .surface-status { font-size: 0.7rem; padding: 1px 6px; border-radius: 8px; margin-left: auto; }
  .surface-status.online { background: #23863633; color: var(--success); }
  .surface-status.offline { background: #da363333; color: var(--error); }
  .surface-stat { font-size: 0.75rem; color: var(--text-dim); }

  /* Marketplace Grid */
  .marketplace-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1rem; }
  .agent-card { padding: 1rem; background: var(--bg); border-radius: 8px; border: 1px solid var(--border);
    transition: border-color 0.2s; cursor: pointer; }
  .agent-card:hover { border-color: var(--accent); }
  .agent-card-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; }
  .agent-avatar { width: 32px; height: 32px; border-radius: 8px; background: var(--border);
    display: flex; align-items: center; justify-content: center; font-size: 0.85rem; font-weight: 700; }
  .agent-name { font-weight: 600; color: var(--text-bright); font-size: 0.9rem; }
  .agent-version { font-size: 0.7rem; color: var(--text-dim); }
  .agent-desc { font-size: 0.8rem; color: var(--text-dim); margin-bottom: 0.5rem;
    overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; }
  .agent-tags { display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 0.5rem; }
  .agent-tag { font-size: 0.65rem; padding: 1px 6px; border-radius: 8px; background: var(--border); color: var(--text-dim); }
  .agent-footer { display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim); }
  .agent-rating { color: var(--warning); }
  .agent-price { color: var(--success); font-weight: 500; }
</style>
</head>
<body>

<div class="header">
  <h1>CortexOS Dashboard</h1>
  <div class="badge" id="conn-badge">Disconnected</div>
  <div class="stats">
    <div>Runs: <span id="stat-runs">0</span></div>
    <div>Success: <span id="stat-success">0%</span></div>
    <div>Cost: <span id="stat-cost">$0.00</span></div>
    <div>Uptime: <span id="stat-uptime">0s</span></div>
  </div>
</div>

<!-- Tab Navigation -->
<div class="tabs">
  <div class="tab active" data-tab="overview">Overview</div>
  <div class="tab" data-tab="topology">Agent Topology</div>
  <div class="tab" data-tab="memory">Memory Explorer</div>
  <div class="tab" data-tab="surfaces">Surfaces</div>
  <div class="tab" data-tab="marketplace">Marketplace</div>
</div>

<!-- Tab: Overview -->
<div class="tab-content active" id="tab-overview">
<div class="container">
  <!-- Pipeline Stage View -->
  <div class="card full-width">
    <h2>Pipeline</h2>
    <div class="pipeline" id="pipeline">
      <div class="stage" data-stage="recall">RECALL</div><span class="stage-arrow">&rarr;</span>
      <div class="stage" data-stage="enhance">ENHANCE</div><span class="stage-arrow">&rarr;</span>
      <div class="stage" data-stage="analyze">ANALYZE</div><span class="stage-arrow">&rarr;</span>
      <div class="stage" data-stage="decompose">DECOMPOSE</div><span class="stage-arrow">&rarr;</span>
      <div class="stage" data-stage="plan">PLAN</div><span class="stage-arrow">&rarr;</span>
      <div class="stage" data-stage="execute">EXECUTE</div><span class="stage-arrow">&rarr;</span>
      <div class="stage" data-stage="verify">VERIFY</div><span class="stage-arrow">&rarr;</span>
      <div class="stage" data-stage="memorize">MEMORIZE</div>
    </div>
  </div>

  <!-- Metrics Cards -->
  <div class="card full-width">
    <h2>Metrics</h2>
    <div class="metrics-grid">
      <div class="metric"><div class="value" id="m-runs">0</div><div class="label">Total Runs</div></div>
      <div class="metric"><div class="value" id="m-success">0%</div><div class="label">Success Rate</div></div>
      <div class="metric"><div class="value" id="m-duration">0ms</div><div class="label">Avg Duration</div></div>
      <div class="metric"><div class="value" id="m-cost">$0.00</div><div class="label">Total Cost</div></div>
    </div>
  </div>

  <!-- Trace Waterfall -->
  <div class="card">
    <h2>Trace Waterfall</h2>
    <div class="waterfall" id="waterfall">
      <div class="empty">No traces yet. Run a task to see execution timeline.</div>
    </div>
  </div>

  <!-- Agent Activity Feed -->
  <div class="card">
    <h2>Activity Feed</h2>
    <div class="feed" id="feed">
      <div class="empty">Waiting for events...</div>
    </div>
  </div>

  <!-- Cost Chart -->
  <div class="card">
    <h2>Cost Over Time</h2>
    <div class="chart-container">
      <canvas id="cost-chart"></canvas>
    </div>
  </div>

  <!-- Quality Chart -->
  <div class="card">
    <h2>Quality Score</h2>
    <div class="chart-container">
      <canvas id="quality-chart"></canvas>
    </div>
  </div>
</div>
</div><!-- /tab-overview -->

<!-- Tab: Agent Topology -->
<div class="tab-content" id="tab-topology">
<div class="container">
  <div class="card full-width">
    <h2>Agent Topology Graph</h2>
    <div class="topology-canvas">
      <canvas id="topology-graph"></canvas>
    </div>
    <div class="topology-legend">
      <div class="legend-item"><span class="legend-dot" style="background:var(--accent)"></span> Orchestrator</div>
      <div class="legend-item"><span class="legend-dot" style="background:var(--success)"></span> Worker Agent</div>
      <div class="legend-item"><span class="legend-dot" style="background:var(--purple)"></span> Specialist</div>
      <div class="legend-item"><span class="legend-dot" style="background:var(--warning)"></span> QA Agent</div>
    </div>
  </div>
  <div class="card">
    <h2>Agent Status</h2>
    <div class="feed" id="agent-status-list">
      <div class="empty">No agents active</div>
    </div>
  </div>
  <div class="card">
    <h2>Communication Log</h2>
    <div class="feed" id="agent-comm-log">
      <div class="empty">No inter-agent messages</div>
    </div>
  </div>
</div>
</div>

<!-- Tab: Memory Explorer -->
<div class="tab-content" id="tab-memory">
<div class="container">
  <div class="card full-width">
    <h2>Memory Explorer</h2>
    <div style="display:flex;gap:0.5rem;margin-bottom:0.75rem;">
      <input id="memory-search" type="text" placeholder="Search memories..."
        style="flex:1;padding:0.4rem 0.75rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:0.85rem;outline:none;">
      <select id="memory-filter" style="padding:0.4rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:0.85rem;">
        <option value="all">All Types</option>
        <option value="semantic">Semantic</option>
        <option value="episodic">Episodic</option>
        <option value="working">Working</option>
      </select>
    </div>
    <div class="memory-list" id="memory-list">
      <div class="empty">No memories stored yet</div>
    </div>
  </div>
  <div class="card">
    <h2>Memory Statistics</h2>
    <div class="metrics-grid">
      <div class="metric"><div class="value" id="mem-total">0</div><div class="label">Total Memories</div></div>
      <div class="metric"><div class="value" id="mem-semantic">0</div><div class="label">Semantic</div></div>
      <div class="metric"><div class="value" id="mem-episodic">0</div><div class="label">Episodic</div></div>
      <div class="metric"><div class="value" id="mem-working">0</div><div class="label">Working</div></div>
    </div>
  </div>
  <div class="card">
    <h2>Recent Recall</h2>
    <div class="feed" id="recall-log">
      <div class="empty">No recent recalls</div>
    </div>
  </div>
</div>
</div>

<!-- Tab: Surfaces -->
<div class="tab-content" id="tab-surfaces">
<div class="container">
  <div class="card full-width">
    <h2>Active Surfaces</h2>
    <div class="surface-grid" id="surface-grid">
      <div class="surface-card">
        <div class="surface-header">
          <span class="surface-icon">GH</span>
          <span class="surface-name">GitHub</span>
          <span class="surface-status offline">offline</span>
        </div>
        <div class="surface-stat">PRs reviewed: 0 | Issues triaged: 0</div>
      </div>
      <div class="surface-card">
        <div class="surface-header">
          <span class="surface-icon">SL</span>
          <span class="surface-name">Slack</span>
          <span class="surface-status offline">offline</span>
        </div>
        <div class="surface-stat">Commands: 0 | Threads: 0</div>
      </div>
      <div class="surface-card">
        <div class="surface-header">
          <span class="surface-icon">DC</span>
          <span class="surface-name">Discord</span>
          <span class="surface-status offline">offline</span>
        </div>
        <div class="surface-stat">Commands: 0 | Interactions: 0</div>
      </div>
      <div class="surface-card">
        <div class="surface-header">
          <span class="surface-icon">MCP</span>
          <span class="surface-name">MCP Server</span>
          <span class="surface-status offline">offline</span>
        </div>
        <div class="surface-stat">Tools exposed: 0 | Calls: 0</div>
      </div>
    </div>
  </div>
  <div class="card">
    <h2>Surface Events</h2>
    <div class="feed" id="surface-feed">
      <div class="empty">No surface events</div>
    </div>
  </div>
  <div class="card">
    <h2>Surface Metrics</h2>
    <div class="metrics-grid">
      <div class="metric"><div class="value" id="sf-active">0</div><div class="label">Active</div></div>
      <div class="metric"><div class="value" id="sf-events">0</div><div class="label">Events Today</div></div>
      <div class="metric"><div class="value" id="sf-errors">0</div><div class="label">Errors</div></div>
      <div class="metric"><div class="value" id="sf-uptime">0%</div><div class="label">Uptime</div></div>
    </div>
  </div>
</div>
</div>

<!-- Tab: Marketplace -->
<div class="tab-content" id="tab-marketplace">
<div class="container">
  <div class="card full-width">
    <h2>Agent Marketplace</h2>
    <div style="display:flex;gap:0.5rem;margin-bottom:1rem;">
      <input id="marketplace-search" type="text" placeholder="Search agents..."
        style="flex:1;padding:0.4rem 0.75rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:0.85rem;outline:none;">
      <select id="marketplace-category" style="padding:0.4rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:0.85rem;">
        <option value="all">All Categories</option>
        <option value="code">Code</option>
        <option value="test">Testing</option>
        <option value="devops">DevOps</option>
        <option value="data">Data</option>
        <option value="security">Security</option>
      </select>
    </div>
    <div class="marketplace-grid" id="marketplace-grid">
      <div class="agent-card">
        <div class="agent-card-header">
          <div class="agent-avatar" style="background:#1f6feb33;color:var(--accent)">CR</div>
          <div><div class="agent-name">Code Reviewer</div><div class="agent-version">v1.2.0</div></div>
        </div>
        <div class="agent-desc">Automated code review with quality scoring, style checks, and security analysis.</div>
        <div class="agent-tags"><span class="agent-tag">code</span><span class="agent-tag">review</span><span class="agent-tag">quality</span></div>
        <div class="agent-footer"><span class="agent-rating">4.8/5</span><span class="agent-price">Free</span></div>
      </div>
      <div class="agent-card">
        <div class="agent-card-header">
          <div class="agent-avatar" style="background:#23863633;color:var(--success)">TG</div>
          <div><div class="agent-name">Test Generator</div><div class="agent-version">v2.0.1</div></div>
        </div>
        <div class="agent-desc">Generates unit tests, integration tests, and E2E test suites from source code.</div>
        <div class="agent-tags"><span class="agent-tag">test</span><span class="agent-tag">generation</span><span class="agent-tag">coverage</span></div>
        <div class="agent-footer"><span class="agent-rating">4.6/5</span><span class="agent-price">Free</span></div>
      </div>
      <div class="agent-card">
        <div class="agent-card-header">
          <div class="agent-avatar" style="background:#d2992233;color:var(--warning)">DP</div>
          <div><div class="agent-name">Deploy Pipeline</div><div class="agent-version">v1.0.0</div></div>
        </div>
        <div class="agent-desc">One-click deployment to Cloudflare, AWS Lambda, Deno Deploy, and Docker.</div>
        <div class="agent-tags"><span class="agent-tag">devops</span><span class="agent-tag">deploy</span><span class="agent-tag">cloud</span></div>
        <div class="agent-footer"><span class="agent-rating">4.5/5</span><span class="agent-price">$0.02/run</span></div>
      </div>
      <div class="agent-card">
        <div class="agent-card-header">
          <div class="agent-avatar" style="background:#bc8cff33;color:var(--purple)">SA</div>
          <div><div class="agent-name">Security Auditor</div><div class="agent-version">v1.1.0</div></div>
        </div>
        <div class="agent-desc">Scans for OWASP Top 10, dependency vulnerabilities, and secret leaks.</div>
        <div class="agent-tags"><span class="agent-tag">security</span><span class="agent-tag">audit</span><span class="agent-tag">owasp</span></div>
        <div class="agent-footer"><span class="agent-rating">4.9/5</span><span class="agent-price">$0.05/run</span></div>
      </div>
      <div class="agent-card">
        <div class="agent-card-header">
          <div class="agent-avatar" style="background:#f8514933;color:var(--error)">DB</div>
          <div><div class="agent-name">Debug Detective</div><div class="agent-version">v1.3.0</div></div>
        </div>
        <div class="agent-desc">Time-travel debugging, root cause analysis, and automated fix suggestions.</div>
        <div class="agent-tags"><span class="agent-tag">debug</span><span class="agent-tag">analysis</span><span class="agent-tag">fix</span></div>
        <div class="agent-footer"><span class="agent-rating">4.7/5</span><span class="agent-price">Free</span></div>
      </div>
      <div class="agent-card">
        <div class="agent-card-header">
          <div class="agent-avatar" style="background:#3fb95033;color:var(--success)">DW</div>
          <div><div class="agent-name">Doc Writer</div><div class="agent-version">v2.1.0</div></div>
        </div>
        <div class="agent-desc">Generates API docs, READMEs, changelogs, and architecture diagrams.</div>
        <div class="agent-tags"><span class="agent-tag">docs</span><span class="agent-tag">api</span><span class="agent-tag">readme</span></div>
        <div class="agent-footer"><span class="agent-rating">4.4/5</span><span class="agent-price">Free</span></div>
      </div>
    </div>
  </div>
</div>
</div>

<script>
(function() {
  const PORT = '__WS_PORT__';
  const BASE = 'http://localhost:' + PORT;
  let ws = null;
  let reconnectTimer = null;
  let reconnectDelay = 1000;
  const feedItems = [];
  const MAX_FEED = 100;

  // DOM refs
  const badge = document.getElementById('conn-badge');
  const feed = document.getElementById('feed');
  const waterfall = document.getElementById('waterfall');

  // ===== WebSocket Connection =====
  function connect() {
    ws = new WebSocket('ws://localhost:' + PORT);

    ws.onopen = function() {
      badge.textContent = 'Connected';
      badge.classList.add('connected');
      reconnectDelay = 1000;
      loadInitialData();
    };

    ws.onclose = function() {
      badge.textContent = 'Disconnected';
      badge.classList.remove('connected');
      reconnectTimer = setTimeout(connect, reconnectDelay);
      reconnectDelay = Math.min(reconnectDelay * 2, 30000);
    };

    ws.onerror = function() { ws.close(); };

    ws.onmessage = function(e) {
      try {
        const msg = JSON.parse(e.data);
        handleEvent(msg.event, msg.data, msg.timestamp);
      } catch(err) { /* ignore parse errors */ }
    };
  }

  // ===== Event Handling =====
  function handleEvent(event, data, ts) {
    // Update pipeline stages
    if (event === 'stage:start' && data && data.stage) {
      setStage(data.stage, 'running');
    } else if (event === 'stage:complete' && data && data.stage) {
      setStage(data.stage, 'done');
    } else if (event === 'engine:start') {
      resetPipeline();
    } else if (event === 'engine:complete') {
      refreshMetrics();
      refreshWaterfall();
    } else if (event === 'engine:error') {
      refreshMetrics();
    }

    // Add to feed
    addFeedItem(event, data, ts);

    // Update cost
    if (event === 'cost:update' && data) {
      document.getElementById('stat-cost').textContent = '$' + (data.totalCost || 0).toFixed(4);
    }
  }

  function setStage(name, state) {
    const stages = document.querySelectorAll('.stage');
    for (const s of stages) {
      if (s.dataset.stage === name.toLowerCase()) {
        s.className = 'stage ' + state;
      }
    }
  }

  function resetPipeline() {
    const stages = document.querySelectorAll('.stage');
    for (const s of stages) { s.className = 'stage'; }
  }

  function addFeedItem(event, data, ts) {
    const time = new Date(ts).toLocaleTimeString();
    const type = event.includes('error') ? 'error' : event.includes('complete') ? 'complete' : 'start';
    const msg = summarizeEvent(event, data);

    feedItems.unshift({ time, event, type, msg });
    if (feedItems.length > MAX_FEED) feedItems.length = MAX_FEED;
    renderFeed();
  }

  function summarizeEvent(event, data) {
    if (!data) return '';
    if (typeof data === 'string') return data;
    if (data.stage) return data.stage;
    if (data.role) return data.role + (data.taskId ? ' (' + data.taskId + ')' : '');
    if (data.message) return data.message;
    if (data.tool) return data.tool;
    return '';
  }

  function renderFeed() {
    if (feedItems.length === 0) {
      feed.innerHTML = '<div class="empty">Waiting for events...</div>';
      return;
    }
    feed.innerHTML = feedItems.map(function(item) {
      return '<div class="feed-item">' +
        '<span class="feed-time">' + item.time + '</span>' +
        '<span class="feed-event ' + item.type + '">' + item.event + '</span>' +
        '<span class="feed-msg">' + escapeHtml(item.msg) + '</span>' +
        '</div>';
    }).join('');
  }

  // ===== API Data Loading =====
  function loadInitialData() {
    refreshMetrics();
    refreshStatus();
    refreshWaterfall();
  }

  function refreshMetrics() {
    fetch(BASE + '/api/metrics').then(function(r) { return r.json(); }).then(function(m) {
      document.getElementById('m-runs').textContent = m.totalRuns || 0;
      document.getElementById('m-success').textContent = ((m.successRate || 0) * 100).toFixed(0) + '%';
      document.getElementById('m-duration').textContent = formatMs(m.avgDuration || 0);
      document.getElementById('m-cost').textContent = '$' + (m.totalCost || 0).toFixed(4);
      document.getElementById('stat-runs').textContent = m.totalRuns || 0;
      document.getElementById('stat-success').textContent = ((m.successRate || 0) * 100).toFixed(0) + '%';
    }).catch(function() {});
  }

  function refreshStatus() {
    fetch(BASE + '/api/status').then(function(r) { return r.json(); }).then(function(s) {
      document.getElementById('stat-uptime').textContent = s.uptimeFormatted || '0s';
      document.getElementById('stat-cost').textContent = '$' + (s.totalCost || 0).toFixed(4);
    }).catch(function() {});
  }

  function refreshWaterfall() {
    fetch(BASE + '/api/traces/timeline').then(function(r) { return r.json(); }).then(function(timeline) {
      if (!timeline || timeline.length === 0) {
        waterfall.innerHTML = '<div class="empty">No traces yet.</div>';
        return;
      }
      var maxEnd = Math.max.apply(null, timeline.map(function(s) { return s.end; })) || 1;
      waterfall.innerHTML = timeline.map(function(span) {
        var left = (span.start / maxEnd * 100).toFixed(1);
        var width = Math.max(((span.end - span.start) / maxEnd * 100), 0.5).toFixed(1);
        var indent = '&nbsp;'.repeat(span.depth * 2);
        return '<div class="waterfall-row">' +
          '<span class="waterfall-name" title="' + escapeHtml(span.name) + '">' + indent + escapeHtml(span.name) + '</span>' +
          '<div class="waterfall-bar-container">' +
          '<div class="waterfall-bar ' + span.kind + '" style="left:' + left + '%;width:' + width + '%"></div>' +
          '</div>' +
          '<span class="waterfall-time">' + formatMs(span.duration) + '</span>' +
          '</div>';
      }).join('');
    }).catch(function() {});
  }

  // ===== Chart Drawing =====
  function drawChart(canvasId, data, color) {
    var canvas = document.getElementById(canvasId);
    if (!canvas || !data || data.length === 0) return;
    var ctx = canvas.getContext('2d');
    var w = canvas.width = canvas.parentElement.clientWidth;
    var h = canvas.height = canvas.parentElement.clientHeight;

    ctx.clearRect(0, 0, w, h);

    var values = data.map(function(d) { return d.value; });
    var max = Math.max.apply(null, values) || 1;
    var step = w / Math.max(values.length - 1, 1);

    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (var i = 0; i < values.length; i++) {
      var x = i * step;
      var y = h - (values[i] / max) * (h - 20) - 10;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Fill area
    ctx.lineTo((values.length - 1) * step, h);
    ctx.lineTo(0, h);
    ctx.closePath();
    ctx.fillStyle = color.replace(')', ', 0.1)').replace('rgb', 'rgba');
    ctx.fill();
  }

  // Load time series for charts
  function loadCharts() {
    fetch(BASE + '/api/metrics/timeseries?field=cost').then(function(r) { return r.json(); }).then(function(d) {
      drawChart('cost-chart', d, 'rgb(88, 166, 255)');
    }).catch(function() {});

    fetch(BASE + '/api/metrics/timeseries?field=quality').then(function(r) { return r.json(); }).then(function(d) {
      drawChart('quality-chart', d, 'rgb(63, 185, 80)');
    }).catch(function() {});
  }

  // ===== Utilities =====
  function formatMs(ms) {
    if (ms < 1000) return Math.round(ms) + 'ms';
    if (ms < 60000) return (ms / 1000).toFixed(1) + 's';
    return (ms / 60000).toFixed(1) + 'm';
  }

  function escapeHtml(s) {
    if (!s) return '';
    return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  }

  // ===== Tab Navigation =====
  document.querySelectorAll('.tab').forEach(function(tab) {
    tab.addEventListener('click', function() {
      document.querySelectorAll('.tab').forEach(function(t) { t.classList.remove('active'); });
      document.querySelectorAll('.tab-content').forEach(function(c) { c.classList.remove('active'); });
      tab.classList.add('active');
      var target = document.getElementById('tab-' + tab.dataset.tab);
      if (target) target.classList.add('active');
      // Trigger tab-specific loads
      if (tab.dataset.tab === 'topology') drawTopology();
      if (tab.dataset.tab === 'memory') loadMemories();
      if (tab.dataset.tab === 'surfaces') loadSurfaces();
      if (tab.dataset.tab === 'marketplace') loadMarketplace();
    });
  });

  // ===== Agent Topology Graph =====
  var topologyNodes = [];
  var topologyEdges = [];

  function drawTopology() {
    var canvas = document.getElementById('topology-graph');
    if (!canvas) return;
    var ctx = canvas.getContext('2d');
    var container = canvas.parentElement;
    var w = canvas.width = container.clientWidth;
    var h = canvas.height = container.clientHeight;

    ctx.clearRect(0, 0, w, h);

    // Demo topology if no live data
    if (topologyNodes.length === 0) {
      topologyNodes = [
        { id: 'orch', label: 'Orchestrator', x: w/2, y: 60, type: 'orchestrator', vx: 0, vy: 0 },
        { id: 'planner', label: 'Planner', x: w/3, y: 150, type: 'worker', vx: 0, vy: 0 },
        { id: 'coder', label: 'Coder', x: w*2/3, y: 150, type: 'worker', vx: 0, vy: 0 },
        { id: 'reviewer', label: 'Reviewer', x: w/4, y: 240, type: 'specialist', vx: 0, vy: 0 },
        { id: 'tester', label: 'Tester', x: w/2, y: 240, type: 'specialist', vx: 0, vy: 0 },
        { id: 'qa', label: 'QA Gate', x: w*3/4, y: 240, type: 'qa', vx: 0, vy: 0 },
      ];
      topologyEdges = [
        { from: 'orch', to: 'planner' }, { from: 'orch', to: 'coder' },
        { from: 'planner', to: 'coder' }, { from: 'coder', to: 'reviewer' },
        { from: 'coder', to: 'tester' }, { from: 'tester', to: 'qa' },
        { from: 'reviewer', to: 'qa' },
      ];
    }

    var nodeMap = {};
    topologyNodes.forEach(function(n) { nodeMap[n.id] = n; });

    var colors = {
      orchestrator: 'var(--accent)', worker: 'var(--success)',
      specialist: 'var(--purple)', qa: 'var(--warning)'
    };
    var colorHex = {
      orchestrator: '#58a6ff', worker: '#3fb950',
      specialist: '#bc8cff', qa: '#d29922'
    };

    // Draw edges
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1.5;
    topologyEdges.forEach(function(e) {
      var from = nodeMap[e.from], to = nodeMap[e.to];
      if (!from || !to) return;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();
      // Arrow
      var angle = Math.atan2(to.y - from.y, to.x - from.x);
      var ax = to.x - 18 * Math.cos(angle), ay = to.y - 18 * Math.sin(angle);
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(ax - 8*Math.cos(angle-0.4), ay - 8*Math.sin(angle-0.4));
      ctx.moveTo(ax, ay);
      ctx.lineTo(ax - 8*Math.cos(angle+0.4), ay - 8*Math.sin(angle+0.4));
      ctx.stroke();
    });

    // Draw nodes
    topologyNodes.forEach(function(n) {
      var c = colorHex[n.type] || '#58a6ff';
      ctx.beginPath();
      ctx.arc(n.x, n.y, 14, 0, Math.PI * 2);
      ctx.fillStyle = c + '33';
      ctx.fill();
      ctx.strokeStyle = c;
      ctx.lineWidth = 2;
      ctx.stroke();
      // Label
      ctx.fillStyle = '#c9d1d9';
      ctx.font = '11px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(n.label, n.x, n.y + 28);
    });
  }

  // ===== Memory Explorer =====
  function loadMemories() {
    fetch(BASE + '/api/memory/recent').then(function(r) { return r.json(); }).then(function(memories) {
      var list = document.getElementById('memory-list');
      if (!memories || memories.length === 0) {
        list.innerHTML = '<div class="empty">No memories stored yet</div>';
        return;
      }
      list.innerHTML = memories.map(function(m) {
        return '<div class="memory-item">' +
          '<span class="memory-type ' + (m.type || 'semantic') + '">' + (m.type || 'semantic') + '</span>' +
          '<span class="memory-content" title="' + escapeHtml(m.content || m.text || '') + '">' + escapeHtml(m.content || m.text || '') + '</span>' +
          '<span class="memory-score">' + ((m.relevance || m.score || 0) * 100).toFixed(0) + '%</span>' +
          '</div>';
      }).join('');
    }).catch(function() {});

    // Stats
    fetch(BASE + '/api/memory/stats').then(function(r) { return r.json(); }).then(function(s) {
      document.getElementById('mem-total').textContent = s.total || 0;
      document.getElementById('mem-semantic').textContent = s.semantic || 0;
      document.getElementById('mem-episodic').textContent = s.episodic || 0;
      document.getElementById('mem-working').textContent = s.working || 0;
    }).catch(function() {});
  }

  // Memory search
  var memSearchInput = document.getElementById('memory-search');
  if (memSearchInput) {
    memSearchInput.addEventListener('input', function() {
      var q = this.value.trim();
      if (q.length < 2) return loadMemories();
      fetch(BASE + '/api/memory/search?q=' + encodeURIComponent(q)).then(function(r) { return r.json(); }).then(function(memories) {
        var list = document.getElementById('memory-list');
        if (!memories || memories.length === 0) {
          list.innerHTML = '<div class="empty">No matches for "' + escapeHtml(q) + '"</div>';
          return;
        }
        list.innerHTML = memories.map(function(m) {
          return '<div class="memory-item">' +
            '<span class="memory-type ' + (m.type || 'semantic') + '">' + (m.type || 'semantic') + '</span>' +
            '<span class="memory-content">' + escapeHtml(m.content || m.text || '') + '</span>' +
            '<span class="memory-score">' + ((m.relevance || m.score || 0) * 100).toFixed(0) + '%</span>' +
            '</div>';
        }).join('');
      }).catch(function() {});
    });
  }

  // ===== Surfaces =====
  function loadSurfaces() {
    fetch(BASE + '/api/surfaces').then(function(r) { return r.json(); }).then(function(surfaces) {
      if (!surfaces || surfaces.length === 0) return;
      var grid = document.getElementById('surface-grid');
      grid.innerHTML = surfaces.map(function(s) {
        var statusClass = s.running ? 'online' : 'offline';
        return '<div class="surface-card">' +
          '<div class="surface-header">' +
          '<span class="surface-icon">' + (s.icon || s.type.substring(0,2).toUpperCase()) + '</span>' +
          '<span class="surface-name">' + escapeHtml(s.name || s.type) + '</span>' +
          '<span class="surface-status ' + statusClass + '">' + (s.running ? 'online' : 'offline') + '</span>' +
          '</div>' +
          '<div class="surface-stat">' + escapeHtml(s.stats || '') + '</div>' +
          '</div>';
      }).join('');
    }).catch(function() {});
  }

  // ===== Marketplace =====
  function loadMarketplace() {
    fetch(BASE + '/api/marketplace/agents').then(function(r) { return r.json(); }).then(function(agents) {
      if (!agents || agents.length === 0) return;
      var grid = document.getElementById('marketplace-grid');
      grid.innerHTML = agents.map(function(a) {
        var initials = (a.name || 'AG').substring(0,2).toUpperCase();
        var tags = (a.tags || []).map(function(t) {
          return '<span class="agent-tag">' + escapeHtml(t) + '</span>';
        }).join('');
        return '<div class="agent-card">' +
          '<div class="agent-card-header">' +
          '<div class="agent-avatar">' + initials + '</div>' +
          '<div><div class="agent-name">' + escapeHtml(a.name) + '</div>' +
          '<div class="agent-version">' + escapeHtml(a.version || 'v1.0.0') + '</div></div>' +
          '</div>' +
          '<div class="agent-desc">' + escapeHtml(a.description || '') + '</div>' +
          '<div class="agent-tags">' + tags + '</div>' +
          '<div class="agent-footer">' +
          '<span class="agent-rating">' + (a.rating || 0).toFixed(1) + '/5</span>' +
          '<span class="agent-price">' + (a.price ? '$' + a.price.toFixed(2) + '/run' : 'Free') + '</span>' +
          '</div></div>';
      }).join('');
    }).catch(function() {});
  }

  // Marketplace search
  var mpSearchInput = document.getElementById('marketplace-search');
  if (mpSearchInput) {
    mpSearchInput.addEventListener('input', function() {
      var q = this.value.trim().toLowerCase();
      var cards = document.querySelectorAll('#marketplace-grid .agent-card');
      cards.forEach(function(card) {
        var name = card.querySelector('.agent-name');
        var desc = card.querySelector('.agent-desc');
        var text = ((name ? name.textContent : '') + ' ' + (desc ? desc.textContent : '')).toLowerCase();
        card.style.display = (!q || text.includes(q)) ? '' : 'none';
      });
    });
  }

  // Also filter topology agent events into comm log
  function handleAgentEvents(event, data, ts) {
    if (event.startsWith('agent:')) {
      var commLog = document.getElementById('agent-comm-log');
      if (commLog && commLog.querySelector('.empty')) commLog.innerHTML = '';
      if (commLog) {
        var time = new Date(ts).toLocaleTimeString();
        var type = event.includes('error') ? 'error' : event.includes('complete') ? 'complete' : 'start';
        commLog.insertAdjacentHTML('afterbegin',
          '<div class="feed-item">' +
          '<span class="feed-time">' + time + '</span>' +
          '<span class="feed-event ' + type + '">' + event + '</span>' +
          '<span class="feed-msg">' + escapeHtml(summarizeEvent(event, data)) + '</span>' +
          '</div>'
        );
      }
    }
    if (event.startsWith('surface:') || event.startsWith('mcp:')) {
      var sfFeed = document.getElementById('surface-feed');
      if (sfFeed && sfFeed.querySelector('.empty')) sfFeed.innerHTML = '';
      if (sfFeed) {
        var time2 = new Date(ts).toLocaleTimeString();
        var type2 = event.includes('error') ? 'error' : event.includes('complete') || event.includes('connected') ? 'complete' : 'start';
        sfFeed.insertAdjacentHTML('afterbegin',
          '<div class="feed-item">' +
          '<span class="feed-time">' + time2 + '</span>' +
          '<span class="feed-event ' + type2 + '">' + event + '</span>' +
          '<span class="feed-msg">' + escapeHtml(summarizeEvent(event, data)) + '</span>' +
          '</div>'
        );
      }
    }
  }

  // Patch handleEvent to also dispatch to new tabs
  var origHandleEvent = handleEvent;
  handleEvent = function(event, data, ts) {
    origHandleEvent(event, data, ts);
    handleAgentEvents(event, data, ts);
  };

  // ===== Init =====
  connect();
  setInterval(refreshStatus, 10000);
  setInterval(loadCharts, 30000);
  setTimeout(loadCharts, 2000);
  setTimeout(drawTopology, 500);
})();
</script>
</body>
</html>
