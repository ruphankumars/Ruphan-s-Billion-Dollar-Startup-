import { describe, it, expect, beforeEach } from 'vitest';
import { SleepReportGenerator } from '../../../src/daemon/sleep-report.js';
import type {
  FileEvent,
  CriticReport,
  SleepReport,
} from '../../../src/daemon/types.js';

describe('SleepReportGenerator', () => {
  let generator: SleepReportGenerator;

  const now = Date.now();
  const basePeriod = { start: now - 8 * 60 * 60 * 1000, end: now };

  const sampleFileEvents: FileEvent[] = [
    { path: '/src/app.ts', type: 'modify', timestamp: now - 3600000, size: 500 },
    { path: '/src/utils.ts', type: 'create', timestamp: now - 1800000, size: 200 },
    { path: '/src/old.ts', type: 'delete', timestamp: now - 900000 },
  ];

  const sampleCriticReport: CriticReport = {
    id: 'report-1',
    timestamp: now - 3600000,
    verdict: 'warn',
    confidence: 0.8,
    issues: [
      {
        severity: 'medium',
        category: 'quality',
        message: 'TODO: Fix this',
        file: '/src/app.ts',
        line: 10,
      },
      {
        severity: 'critical',
        category: 'security',
        message: 'Potential API key detected',
        file: '/src/config.ts',
        line: 5,
        suggestedFix: 'Move to environment variables',
      },
    ],
    suggestions: ['Address security issues'],
    duration: 150,
  };

  beforeEach(() => {
    generator = new SleepReportGenerator();
  });

  describe('generate()', () => {
    it('creates a valid SleepReport', () => {
      const report = generator.generate({
        period: basePeriod,
        fileEvents: sampleFileEvents,
        criticReports: [sampleCriticReport],
      });

      expect(report).toBeDefined();
      expect(report.id).toBeDefined();
      expect(typeof report.generatedAt).toBe('number');
      expect(report.period).toEqual(basePeriod);
      expect(typeof report.summary).toBe('string');
      expect(report.summary.length).toBeGreaterThan(0);
      expect(report.filesChanged).toBe(3); // 3 unique file paths
      expect(report.criticsRun).toBe(1);
      expect(report.issuesFound).toBe(2);
      expect(report.confidence).toBeDefined();
      expect(typeof report.confidence.overall).toBe('number');
      expect(Array.isArray(report.recommendations)).toBe(true);
      expect(Array.isArray(report.sections)).toBe(true);
      expect(report.sections.length).toBeGreaterThan(0);
    });

    it('handles empty data', () => {
      const report = generator.generate({
        period: basePeriod,
        fileEvents: [],
        criticReports: [],
      });

      expect(report).toBeDefined();
      expect(report.filesChanged).toBe(0);
      expect(report.criticsRun).toBe(0);
      expect(report.issuesFound).toBe(0);
    });

    it('includes execution results if provided', () => {
      const report = generator.generate({
        period: basePeriod,
        fileEvents: [],
        criticReports: [],
        executionResults: [
          { prompt: 'Fix bug', success: true, duration: 5000, cost: 0.01 },
          { prompt: 'Add tests', success: false, duration: 3000 },
        ],
      });

      expect(report.summary).toContain('Execution success rate');
      const execSection = report.sections.find(
        (s) => s.title === 'Execution Results',
      );
      expect(execSection).toBeDefined();
    });
  });

  describe('formatMarkdown()', () => {
    it('returns markdown string', () => {
      const report = generator.generate({
        period: basePeriod,
        fileEvents: sampleFileEvents,
        criticReports: [sampleCriticReport],
      });

      const md = generator.formatMarkdown(report);

      expect(typeof md).toBe('string');
      expect(md).toContain('# CortexOS Sleep Report');
      expect(md).toContain('## Summary');
      expect(md).toContain('## Key Metrics');
      expect(md).toContain('Files Changed');
      expect(md).toContain('## Recommendations');
      expect(md).toContain('Generated by CortexOS Ambient Engine');
    });
  });

  describe('formatJSON()', () => {
    it('returns valid JSON string', () => {
      const report = generator.generate({
        period: basePeriod,
        fileEvents: sampleFileEvents,
        criticReports: [sampleCriticReport],
      });

      const jsonStr = generator.formatJSON(report);

      expect(typeof jsonStr).toBe('string');
      const parsed = JSON.parse(jsonStr);
      expect(parsed.id).toBe(report.id);
      expect(parsed.generatedAt).toBe(report.generatedAt);
      expect(parsed.filesChanged).toBe(report.filesChanged);
    });
  });

  describe('summarizeChanges()', () => {
    it('summarizes various file events', () => {
      const summary = generator.summarizeChanges(sampleFileEvents);

      expect(typeof summary).toBe('string');
      expect(summary).toContain('3 file event(s)');
      expect(summary).toContain('1 modified');
      expect(summary).toContain('1 created');
      expect(summary).toContain('1 deleted');
      expect(summary).toContain('.ts');
    });

    it('returns message for no events', () => {
      const summary = generator.summarizeChanges([]);
      expect(summary).toContain('No file changes');
    });
  });

  describe('generateRecommendations()', () => {
    it('recommends security fixes for security issues', () => {
      const recs = generator.generateRecommendations(
        [sampleCriticReport],
        sampleFileEvents,
      );

      expect(recs.length).toBeGreaterThan(0);
      const securityRec = recs.find((r) => r.includes('security'));
      expect(securityRec).toBeDefined();
    });

    it('recommends addressing critical issues', () => {
      const recs = generator.generateRecommendations(
        [sampleCriticReport],
        sampleFileEvents,
      );

      const criticalRec = recs.find((r) => r.includes('critical'));
      expect(criticalRec).toBeDefined();
    });

    it('returns positive message when no issues', () => {
      const cleanReport: CriticReport = {
        id: 'clean',
        timestamp: now,
        verdict: 'pass',
        confidence: 1.0,
        issues: [],
        suggestions: [],
        duration: 50,
      };

      const recs = generator.generateRecommendations(
        [cleanReport],
        sampleFileEvents,
      );

      const positiveRec = recs.find((r) => r.includes('good work'));
      expect(positiveRec).toBeDefined();
    });

    it('detects high-churn files', () => {
      const highChurnEvents: FileEvent[] = Array.from({ length: 10 }, (_, i) => ({
        path: '/src/hot-file.ts',
        type: 'modify' as const,
        timestamp: now - i * 60000,
      }));

      const recs = generator.generateRecommendations([], highChurnEvents);

      const churnRec = recs.find((r) => r.includes('high change frequency'));
      expect(churnRec).toBeDefined();
    });
  });
});
